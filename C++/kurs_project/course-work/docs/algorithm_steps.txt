Алгоритм 1. Загрузка данных при старте программы
Шаг-1: Определить рабочий каталог и вычислить путь до папки `data`.
Шаг-2: Для каждого файла (`employees.txt`, `departments.txt`, `positions.txt`, `hires.txt`) сформировать абсолютный путь с помощью `combinePath`.
Шаг-3: Очистить контейнеры сотрудников, отделов, должностей; сбросить словари индексов и счетчики `nextEmployeeId`, `nextDepartmentId`, `nextPositionId`.
Шаг-4: Очистить стек undo и снять флаг `undoInProgress`.
Шаг-5: Открыть `positions.txt`, построчно читать данные о должностях.
Шаг-6: Для каждой строки должности создать объект `Position`, добавить его в контейнер и обновить карту индексов, коррелируя `positionId`.
Шаг-7: Открыть `departments.txt` и считать сведения об отделах.
Шаг-8: Создать объекты `Department`, восстановить список сотрудников отдела, обновить карту `departmentIndex`.
Шаг-9: Открыть `employees.txt`, определить тип сотрудника (MANAGER/WORKER), создать соответствующий объект через `std::make_shared`.
Шаг-10: Добавить `EmployeeRecord` в основной контейнер, зарегистрировать сотрудника в индексах, обновить `nextEmployeeId`.
Шаг-11: Привязать сотрудника к отделу через `ensureDepartmentContainsEmployee`, чтобы восстановить связь.
Шаг-12: Открыть `hires.txt`, считать даты найма, обновить поле `HireDate` в соответствующих `EmployeeRecord`.
Шаг-13: После успешного чтения задать флаг готовности (программа может обрабатывать запросы).

Алгоритм 2. Добавление нового работника
Шаг-1: Считать из меню имя, фамилию, идентификатор отдела, должности, оклад, премию и параметры даты найма.
Шаг-2: Проверить существование отдела через `findDepartment`; при отсутствии вывести сообщение и прекратить операцию.
Шаг-3: Проверить существование должности через `findPosition`; при отсутствии также завершить операцию.
Шаг-4: Сгенерировать новый `employeeId` вызовом `generateEmployeeId`.
Шаг-5: Создать объект `Worker` с переданными параметрами и значением премии.
Шаг-6: Создать `EmployeeRecord`, скопировать дату найма и присвоить ей новый идентификатор сотрудника.
Шаг-7: Добавить запись в контейнер сотрудников, вызвать `registerEmployee` для обновления индексной карты.
Шаг-8: Вызвать `ensureDepartmentContainsEmployee` для добавления сотрудника в список отдела.
Шаг-9: Сформировать undo-команду, которая удалит сотрудника, и поместить ее на стек (если не активен режим undo).
Шаг-10: Сообщить пользователю об успешном добавлении.

Алгоритм 3. Поиск сотрудников по критериям
Шаг-1: Из интерфейса получить строковые значения фильтров (отдел, должность, минимальная/максимальная зарплата, фрагмент имени).
Шаг-2: Для каждого введенного значения проверить корректность и установить соответствующие флаги в `EmployeeSearchFilter`.
Шаг-3: Инициализировать пустой вектор результатов.
Шаг-4: Пройти по всему контейнеру сотрудников (`employees.begin()` → `employees.end()`).
Шаг-5: Для каждой записи проверить: совпадает ли отдел (при активном фильтре).
Шаг-6: Проверить попадание зарплаты в указанный диапазон.
Шаг-7: Если включен фильтр по должности, удостовериться, что сотрудник — `Worker` и должность совпадает.
Шаг-8: При включенном поиске по строке выполнить поиск подстроки в `getFullName()`.
Шаг-9: Если все проверки пройдены, добавить запись в результирующий список.
Шаг-10: По завершении обхода вывести результат пользователю.

Алгоритм 4. Отмена последнего действия (Undo)
Шаг-1: Проверить, не пуст ли стек undo; если пуст, уведомить пользователя и завершить операцию.
Шаг-2: Снять верхнюю команду со стека и сохранить ее локально.
Шаг-3: Установить флаг `undoInProgress = true`, чтобы внутренняя логика не создавала дополнительных команд отмены.
Шаг-4: Вызвать сохраненную лямбда-функцию `undo()` для восстановления предыдущего состояния (например, добавление/удаление сотрудника).
Шаг-5: После выполнения вернуть флаг `undoInProgress` в значение `false`.
Шаг-6: Вывести сообщение «Отменено: <описание>».
Шаг-7: Вернуться в основной цикл обработки команд.

